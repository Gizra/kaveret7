<?php

define('CODIFY_DIR', conf_path());//often the files directory is not under version control

/*
 * implements hook_install
 */
function devel_codify_install() {
  if (module_exists('admin_menu')) {
    module_load_include('inc', 'admin_menu');
    $modules = variable_get('admin_menu_devel_modules', _admin_menu_developer_modules());
    $modules[] = 'devel_codify';
    variable_set('admin_menu_devel_modules', $modules);
  }
}

/*
 * implements hook_menu
 */
function devel_codify_menu() {
  $items['devel/export'] = array(
    'title' => "Export fields, blocks, & views",
    'page callback' => 'devel_codify',
    'page arguments' => array(1),
    'access arguments' => array('administer nodes'),
    'menu_name' => 'devel',
    'weight' => 5
  );
  $items['devel/import'] = array(
    'title' => "import fields, blocks, & views",
    'page callback' => 'devel_import',
    'page arguments' => array(1),
    'access arguments' => array('administer nodes'),
    'menu_name' => 'devel',
    'weight' => 6
  );
  return $items;
}


/*
 * implements admin_menu hook_admin_menu_output_build
 * adds the import and export links to the admin menu
 */
function devel_codify_admin_menu_output_build(&$content) {
  $destination = drupal_get_destination();
  $content['icon']['icon']['export'] = array(
    '#title' => t('Config dump to code'),
    '#weight' => 50,
    '#access' => user_access('administer site configuration'),
    '#href' => 'devel/export',
    '#options' => array(
      'query' => $destination + array('token' => drupal_get_token('devel/export')),
    ),
  );
  $content['icon']['icon']['import'] = array(
    '#title' => t('Config import dump'),
    '#weight' => 50,
    '#access' => user_access('administer site configuration'),
    '#href' => 'devel/import',
    '#options' => array(
      'query' => $destination + array('token' => drupal_get_token('devel/import')),
    ),
  );
}

/*
 * menu callback
 */
function devel_codify() {
  $directory = CODIFY_DIR.'/devel';
  file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
  include_once DRUPAL_ROOT . '/includes/utility.inc';
  //if (module_exists('views')) devel_codify_views();
  foreach (devel_codify_type_info() as $type => $plural_name) {
    $data = '';
    if (substr($type, 0, 6) == 'ctools') {
      $count = devel_codify_ctools(substr($type, 7), $data);
    }
    else {
      $function = 'devel_codify_'.$type;
      $count = $function($data);
    }
    $filename = $type . '.export.php';
    file_unmanaged_save_data($data, $directory .'/'.$filename, FILE_EXISTS_REPLACE);
    drupal_set_message(t('Dumped @count @types', array('@types' => $plural_name, '@count' => $count)));
  }
  drupal_goto();
}

/*
 * menu callback
 * //this should really be batched...
 */
function devel_import() {
  foreach (devel_codify_type_info() as $type => $plural_name) {
    $uri = CODIFY_DIR.'/devel/'.$type.'.export.php';
    if (substr($type, 0, 6) != 'ctools') {
      $function = 'devel_import_'.$type;
      include($uri);
      $count = $function($$type);
    }
    else {//ctools
      $table = substr($type, 7);
      $count = devel_import_ctools($table, file_get_contents($uri));
    }
    unset($$type);//to save memory
    drupal_set_message(t('Imported @count @types', array('@types' => $plural_name, '@count' => $count)));
  }
  drupal_goto();
}


/*
 * fieldAPI fields
 * which fortunately has an easy way
 * that's part of what 'API' means
 */
function devel_codify_fields(&$output) {
  $output = "<?php\n";
  $output .= '$fields = array();'."\n";
  $fields = field_read_fields();
  foreach ($fields as $field_info) {
    $output .= '$fields[] = ' . drupal_var_export($field_info) . ";\n";
  }
  return count($fields);
}
/**
 *import fields from file
 * Assume the fields on file are the whole lot, but they may have been edited
 * therefore ids must be preserved for imported fields, and fields not imported must be removed
 */
function devel_import_fields(&$fields) {
  //we now have an array called $fields
  foreach ($fields as $field) {
    field_update_field($field);
    $preserve_fields[] = $field['id'];
  }
  db_delete('field_config')->condition('id', $preserve_fields, 'NOT IN');
  return count($fields);
}

/*
 * fieldAPI fields
 * which fortunately has an easy way
 */
function devel_codify_instances(&$output) {
  $output = "<?php\n";
  $output .= '$instances = array();'."\n";
  $instances = field_read_instances();
  foreach ($instances as $instance_info) {
    $output .= '$instances[] = ' . drupal_var_export($instance_info) . ";\n";
  }
  return count($instances);
}

function devel_import_instances(&$instances) {
  //we now have an array called $instances
  foreach ($instances as $instance) {
    field_update_instance($instance);
    $preserve_instances[] = $instance['id'];
  }
  db_delete('field_config_instance')->condition('id', $preserve_instances, 'NOT IN')->execute();
  return count($instances);
}

/**
 * Blocks
 * we're going to have to be a bit rougher than with fields, doing what amounts to a database dump
 * a block is an internal data object only, derived and calculated. there are no crud operations
 * so we have to work much closer to the database.
 * TODO save the block roles as well
 */
function devel_codify_blocks(&$output) {
  $output = "<?php\n";
  $output .= '$blocks = array();'."\n";
  //only bother with blocks in active themes
  foreach(list_themes() as $key => $info) if ($info->status)$themes[] = $key;
  $blocks = db_select('block', 'b')->fields('b')->condition('theme', $themes)->execute()->fetchAll();
  foreach ($blocks as $block) {
    $output .= '$blocks[] = ' . drupal_var_export((array)$block) . ";\n";
  }
  return count($blocks);
}
function devel_import_blocks(&$blocks) {
  foreach(list_themes() as $key => $info) if ($info->status)$themes[] = $key;
  include('public://devel/instances.export.php');
  //we now have an array called $blocks
  foreach($blocks as $block) {
    $bids[] = $block['bid'];
    drupal_write_record('block', $block, array('bid'));//not using the usual block keys
  }
  $remove = db_select('block', 'b')->fields('b', 'bid')
  ->condition('bid', $bids, 'NOT IN')
  ->condition('theme', $themes, 'NOT IN')
  ->execute()->fetchCol();
  if (count($remove)) {
    drupal_set_message(t('removing / resetting @count blocks', array('@count' => count)));
    db_delete('block')->condition('bid', $remove)->execute();
  }
  return count($bids);
}

/*
 * Views
 */
function devel_codify_ctools($table, &$output) {
  $output = "<?php\n";
  //this gets all the objects, from code and database
  //we have no way to distinguish between them
  $views = ctools_export_load_object($table);
  foreach ($views as $view) {
    $blobs[] = "\n".ctools_export_crud_export($table, $view) ."\n";
  }
  $output .= implode("<<<>>>", $blobs);
  return count($views);
}

function devel_import_ctools($table, &$string) {
  $code_objects = explode('<<<>>>', $string);
  $existing = ctools_export_load_object($table);
  foreach ($code_objects as $code) {
    //the import doesn't seem to overwrite the views in code, thankfully
    $object = ctools_export_crud_import($table, $code);
    $preserve[] = $object->name;//I'm not sure all ctools have a name property
  }
  debug($preserve, 'imported view names');
  foreach($existing as $name => $object) {
    if (!in_array($name, $preserve)) {
      debug('testing: would delete '.$name);
      ctools_export_crud_delete($table, $object);//does this work?
      //assume this is views only
      //views_delete_view($object);
    }
  }
  return count($code_objects);
}



function devel_codify_type_info() {
  if (module_exists('field')) {
    $types['fields'] = t('fields');
    $types['instances'] = t('instances');
    cache_clear_all(NULL, 'cache_field');
  }
  if (module_exists('block')) {
    $types['blocks'] = t('blocks');
  }
  if (module_exists('views')) {
    ctools_include('export');
    cache_clear_all(NULL, 'cache_views');
    cache_clear_all(NULL, 'cache_views_data');
    $types['ctools-views_view'] = t('views');
  }
  return $types;
}
